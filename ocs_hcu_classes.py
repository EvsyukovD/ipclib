# Current classes inspired by linux intel crypto driver for keembay (https://github.com/torvalds/linux/blob/master/drivers/crypto/intel/keembay/ocs-hcu.h)
# https://elixir.bootlin.com/linux/latest/source/drivers/crypto/intel/keembay/ocs-hcu.h
from dev_common import *

OCS_HCU_DMA_BIT_MASK = bit_mask(32)

OCS_HCU_HW_KEY_LEN = 64

SHA512_DIGEST_SIZE = 64

SHA256_DIGEST_SIZE = 256 // 8

SHA384_DIGEST_SIZE = 384 // 8

SHA224_DIGEST_SIZE = 224 // 8

SHA1_DIGEST_SIZE = 20

class ocs_hcu_algo(object):
    OCS_HCU_ALGO_SHA1 = 0
    OCS_HCU_ALGO_SHA256 = 2
    OCS_HCU_ALGO_SHA224 = 3
    OCS_HCU_ALGO_SHA384 = 4
    OCS_HCU_ALGO_SHA512 = 5
    OCS_HCU_ALGO_SM3 = 6


'''
/**
 * struct ocs_hcu_dev - OCS HCU device context.
 * @list:	List of device contexts.
 * @dev:	OCS HCU device.
 * @io_base:	Base address of OCS HCU registers.
 * @engine:	Crypto engine for the device.
 * @irq:	IRQ number.
 * @irq_done:	Completion for IRQ.
 * @irq_err:	Flag indicating an IRQ error has happened.
 */
struct ocs_hcu_dev {
	struct list_head list;
	struct device *dev;
	void __iomem *io_base;
	struct crypto_engine *engine;
	int irq;
	struct completion irq_done;
	bool irq_err;
};
 '''


class ocs_hcu_dev(object):
    def __init__(self, device=None, io_base=None, engine=None, irq=0, irq_done=None, irq_err=False):
        self.list = list()  # struct list_head
        self.dev = device  # struct device
        self.io_base = io_base  # void __iomem *io_base;
        self.engine = engine  # struct crypto_engine *engine
        self.irq = irq
        self.irq_done = irq_done
        self.irq_err = irq_err


'''
/**
 * struct ocs_hcu_idata - Intermediate data generated by the HCU.
 * @msg_len_lo: Length of data the HCU has operated on in bits, low 32b.
 * @msg_len_hi: Length of data the HCU has operated on in bits, high 32b.
 * @digest: The digest read from the HCU. If the HCU is terminated, it will
 *	    contain the actual hash digest. Otherwise it is the intermediate
 *	    state.
 */
struct ocs_hcu_idata {
	u32 msg_len_lo;
	u32 msg_len_hi;
	u8  digest[SHA512_DIGEST_SIZE];
};
'''


class ocs_hcu_idata(object):
    def __init__(self):
        self.msg_len_lo = 0
        self.msg_len_hi = 0
        self.digest = bytearray([0] * SHA512_DIGEST_SIZE)


'''
/**
 * struct ocs_hcu_hash_ctx - Context for OCS HCU hashing operation.
 * @algo:	The hashing algorithm being used.
 * @idata:	The current intermediate data.
 */
struct ocs_hcu_hash_ctx {
	enum ocs_hcu_algo	algo;
	struct ocs_hcu_idata	idata;
};
'''


class ocs_hcu_hash_ctx(object):
    def __init__(self):
        self.algo = ocs_hcu_algo.OCS_HCU_ALGO_SHA256  # default value
        self.idata = ocs_hcu_idata()


'''
/**
 * struct ocs_hcu_dma_entry - An entry in an OCS DMA linked list.
 * @src_addr:  Source address of the data.
 * @src_len:   Length of data to be fetched.
 * @nxt_desc:  Next descriptor to fetch.
 * @ll_flags:  Flags (Freeze @ terminate) for the DMA engine.
 */
struct ocs_hcu_dma_entry {
	u32 src_addr;
	u32 src_len;
	u32 nxt_desc;
	u32 ll_flags;
};
'''


class ocs_hcu_dma_entry(object):
    def __init__(self):
        self.src_addr = 0
        self.src_len = 0
        self.nxt_desc = 0
        self.ll_flags = 0


'''
Write dma_entry struct to memory
'''


def write_dma_entry(entry, address):
    HCU_DMA_ENTRY_SIZE = 16
    iowrite32(entry.src_addr, address)
    address += 4
    iowrite32(entry.src_len, address)
    address += 4
    iowrite32(entry.nxt_desc, address)
    address += 4
    iowrite32(entry.ll_flags, address)


'''
Read dma_entry struct from memory
'''


def read_dma_entry(address):
    entry = ocs_hcu_dma_entry()
    entry.src_addr = ioread32(address)
    address += 4
    entry.src_len = ioread32(address)
    address += 4
    entry.nxt_desc = ioread32(address)
    address += 4
    entry.ll_flags = ioread32(address)


'''
Write dma_entry structure to HCU DMA (write whole structure to 1 address)
'''


def write_dma_entry_to_hcu_dma(address, entry):
    iowrite32(entry.src_addr, address)
    iowrite32(entry.src_len, address)
    iowrite32(entry.nxt_desc, address)
    iowrite32(entry.ll_flags, address)





'''
/**
 * struct ocs_hcu_dma_list - OCS-specific DMA linked list.
 * @head:	The head of the list (points to the array backing the list).
 * @tail:	The current tail of the list; NULL if the list is empty.
 * @dma_addr:	The DMA address of @head (i.e., the DMA address of the backing
 *		array).
 * @max_nents:	Maximum number of entries in the list (i.e., number of elements
 *		in the backing array).
 *
 * The OCS DMA list is an array-backed list of OCS DMA descriptors. The array
 * backing the list is allocated with dma_alloc_coherent() and pointed by
 * @head.
 */
struct ocs_hcu_dma_list {
	struct ocs_hcu_dma_entry	*head;
	struct ocs_hcu_dma_entry	*tail;
	dma_addr_t			dma_addr;
	size_t				max_nents;
};
'''


class ocs_hcu_dma_list(object):
    def __init__(self):
        self.head = None
        self.tail = None
        self.dma_addr = 0
        self.max_nents = 0
        self.size = 0
